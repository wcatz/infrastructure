name: Helmfile Apply

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'default'
        type: choice
        options:
          - default
          - dev
          - staging
          - production

# Use OIDC for secure authentication instead of long-lived credentials
permissions:
  contents: read
  id-token: write  # Required for OIDC

jobs:
  validate-before-deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Install yamllint
        run: |
          pip install yamllint

      - name: Lint YAML files
        run: |
          echo "Linting Helmfile YAML files..."
          yamllint helmfile/

          echo "✅ YAML validation passed"

  helmfile-apply:
    runs-on: ubuntu-latest
    needs: validate-before-deploy
    environment: ${{ github.event.inputs.environment }}
    permissions:
      contents: read
      id-token: write  # Required for OIDC
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      # OIDC Authentication for AWS (if using AWS)
      # Uncomment and configure for AWS-based infrastructure
      # - name: Configure AWS Credentials (OIDC)
      #   uses: aws-actions/configure-aws-credentials@v4
      #   with:
      #     role-to-assume: arn:aws:iam::ACCOUNT_ID:role/github-actions-role
      #     role-session-name: helmfile-deploy-${{ github.run_id }}
      #     aws-region: us-west-2

      # OIDC Authentication for Azure (if using Azure)
      # Uncomment and configure for Azure-based infrastructure
      # - name: Azure Login (OIDC)
      #   uses: azure/login@v1
      #   with:
      #     client-id: ${{ secrets.AZURE_CLIENT_ID }}
      #     tenant-id: ${{ secrets.AZURE_TENANT_ID }}
      #     subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      # OIDC Authentication for GCP (if using GCP)
      # Uncomment and configure for GCP-based infrastructure
      # - name: Authenticate to GCP (OIDC)
      #   uses: google-github-actions/auth@v2
      #   with:
      #     workload_identity_provider: 'projects/PROJECT_NUMBER/locations/global/workloadIdentityPools/POOL_ID/providers/PROVIDER_ID'
      #     service_account: 'github-actions@PROJECT_ID.iam.gserviceaccount.com'

      - name: Setup Helm
        uses: azure/setup-helm@v4
        with:
          version: 'v3.13.3'

      - name: Setup Helmfile
        uses: mamezou-tech/setup-helmfile@v2.1.0
        with:
          helmfile-version: 'v0.159.0'

      - name: Setup kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'v1.28.0'

      - name: Setup SOPS
        run: |
          # Install SOPS for secret decryption with age encryption
          wget -O /tmp/sops https://github.com/mozilla/sops/releases/download/v3.8.1/sops-v3.8.1.linux.amd64
          chmod +x /tmp/sops
          sudo mv /tmp/sops /usr/local/bin/sops
          sops --version

      - name: Setup age for SOPS decryption
        run: |
          # Install age for SOPS encryption/decryption
          wget https://github.com/FiloSottile/age/releases/download/v1.1.1/age-v1.1.1-linux-amd64.tar.gz
          tar xzf age-v1.1.1-linux-amd64.tar.gz
          sudo mv age/age age/age-keygen /usr/local/bin/
          age --version

      - name: Configure SOPS Age Key (from GitHub Encrypted Secrets)
        env:
          SOPS_AGE_KEY: ${{ secrets.SOPS_AGE_KEY }}
        run: |
          # Configure age key for SOPS decryption from GitHub encrypted secrets
          # The SOPS_AGE_KEY secret should contain the private key from ~/.config/sops/age/keys.txt
          # This is stored as an encrypted secret in GitHub Actions (not in repository)
          # Rotation: Update this secret quarterly (see SECRETS.md for rotation procedures)
          mkdir -p ~/.config/sops/age
          echo "$SOPS_AGE_KEY" > ~/.config/sops/age/keys.txt
          chmod 600 ~/.config/sops/age/keys.txt

          # Verify SOPS can read the key
          echo "SOPS age key configured successfully"

      - name: Configure Kubernetes Context
        env:
          KUBECONFIG_DEV: ${{ secrets.KUBECONFIG_DEV }}
          KUBECONFIG_STAGING: ${{ secrets.KUBECONFIG_STAGING }}
          KUBECONFIG_PRODUCTION: ${{ secrets.KUBECONFIG_PRODUCTION }}
          KUBECONFIG_DEFAULT: ${{ secrets.KUBECONFIG }}
        run: |
          mkdir -p $HOME/.kube

          # Select appropriate kubeconfig based on environment input
          ENV="${{ github.event.inputs.environment }}"

          case "$ENV" in
            dev)
              if [ -z "$KUBECONFIG_DEV" ]; then
                echo "❌ Error: KUBECONFIG_DEV secret not set"
                echo "Please configure the KUBECONFIG_DEV secret in repository settings"
                exit 1
              fi
              echo "$KUBECONFIG_DEV" | base64 -d > $HOME/.kube/config
              ;;
            staging)
              if [ -z "$KUBECONFIG_STAGING" ]; then
                echo "❌ Error: KUBECONFIG_STAGING secret not set"
                echo "Please configure the KUBECONFIG_STAGING secret in repository settings"
                exit 1
              fi
              echo "$KUBECONFIG_STAGING" | base64 -d > $HOME/.kube/config
              ;;
            production)
              if [ -z "$KUBECONFIG_PRODUCTION" ]; then
                echo "❌ Error: KUBECONFIG_PRODUCTION secret not set"
                echo "Please configure the KUBECONFIG_PRODUCTION secret in repository settings"
                exit 1
              fi
              echo "$KUBECONFIG_PRODUCTION" | base64 -d > $HOME/.kube/config
              ;;
            default)
              if [ -z "$KUBECONFIG_DEFAULT" ]; then
                echo "❌ Error: KUBECONFIG secret not set"
                echo "Please configure the KUBECONFIG secret in repository settings"
                exit 1
              fi
              echo "$KUBECONFIG_DEFAULT" | base64 -d > $HOME/.kube/config
              ;;
            *)
              echo "❌ Error: Unknown environment: $ENV"
              exit 1
              ;;
          esac

          chmod 600 $HOME/.kube/config
          echo "✅ Kubernetes context configured for environment: $ENV"

          # Verify connection
          kubectl cluster-info || echo "⚠️ Warning: Unable to connect to cluster"

      - name: Helmfile Diff (Pre-deployment)
        working-directory: helmfile
        run: |
          echo "Running helmfile diff for environment: ${{ github.event.inputs.environment }}"
          if [ "${{ github.event.inputs.environment }}" = "default" ]; then
            helmfile diff --suppress-secrets || true
          else
            helmfile -e ${{ github.event.inputs.environment }} diff --suppress-secrets || true
          fi

      - name: Helmfile Apply
        working-directory: helmfile
        run: |
          echo "Running helmfile apply for environment: ${{ github.event.inputs.environment }}"
          if [ "${{ github.event.inputs.environment }}" = "default" ]; then
            helmfile apply --suppress-secrets
          else
            helmfile -e ${{ github.event.inputs.environment }} apply --suppress-secrets
          fi

      - name: Wait for Deployments to be Ready
        run: |
          echo "⏳ Waiting for deployments to become ready..."

          # Determine namespace based on environment
          ENV="${{ github.event.inputs.environment }}"
          case "$ENV" in
            production|prod)
              NAMESPACES="production monitoring cloudflare"
              ;;
            staging)
              NAMESPACES="staging monitoring"
              ;;
            dev)
              NAMESPACES="dev"
              ;;
            default)
              NAMESPACES="default"
              ;;
            *)
              NAMESPACES="default"
              ;;
          esac

          # Wait for deployments in each namespace
          for ns in $NAMESPACES; do
            echo "Checking namespace: $ns"
            if kubectl get namespace "$ns" >/dev/null 2>&1; then
              echo "Waiting for deployments in $ns..."
              kubectl wait --for=condition=available --timeout=300s deployment --all -n "$ns" || echo "⚠️ Some deployments in $ns did not become ready in time"
            else
              echo "Namespace $ns does not exist, skipping..."
            fi
          done

          echo "✅ Deployment wait completed"

      - name: Verify Deployment
        run: |
          echo "Verifying deployment..."
          kubectl get pods -A
          kubectl get svc -A

      - name: Deployment Summary
        run: |
          echo "✅ Helmfile deployment completed successfully"
          echo "Environment: ${{ github.event.inputs.environment }}"
          echo "Triggered by: ${{ github.actor }}"
          echo "Commit SHA: ${{ github.sha }}"
          echo "Timestamp: $(date -u +"%Y-%m-%d %H:%M:%S UTC")"

          echo "## Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: ${{ github.event.inputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Triggered by**: ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit**: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: ✅ Success" >> $GITHUB_STEP_SUMMARY
